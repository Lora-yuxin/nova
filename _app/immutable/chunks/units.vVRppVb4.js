import{o as B,p as x,l as d,q as a,r as I,s as N,t as F,v as T,w as b,x as U}from"./apis.W9dsQ1rZ.js";const A=BigInt(-1),u=BigInt(0),g=BigInt(1),E=BigInt(5),c={};let m="0000";for(;m.length<80;)m+=m;function f(s){let t=m;for(;t.length<s;)t+=t;return BigInt("1"+t.substring(0,s))}function v(s,t,e){const i=BigInt(t.width);if(t.signed){const n=g<<i-g;a(e==null||s>=-n&&s<n,"overflow","NUMERIC_FAULT",{operation:e,fault:"overflow",value:s}),s>u?s=b(U(s,i),i):s=-b(U(-s,i),i)}else{const n=g<<i;a(e==null||s>=0&&s<n,"overflow","NUMERIC_FAULT",{operation:e,fault:"overflow",value:s}),s=(s%n+n)%n&n-g}return s}function p(s){typeof s=="number"&&(s=`fixed128x${s}`);let t=!0,e=128,i=18;if(typeof s=="string"){if(s!=="fixed")if(s==="ufixed")t=!1;else{const r=s.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);d(r,"invalid fixed format","format",s),t=r[1]!=="u",e=parseInt(r[2]),i=parseInt(r[3])}}else if(s){const r=s,o=(l,w,S)=>r[l]==null?S:(d(typeof r[l]===w,"invalid fixed format ("+l+" not "+w+")","format."+l,r[l]),r[l]);t=o("signed","boolean",t),e=o("width","number",e),i=o("decimals","number",i)}d(e%8===0,"invalid FixedNumber width (not byte aligned)","format.width",e),d(i<=80,"invalid FixedNumber decimals (too large)","format.decimals",i);const n=(t?"":"u")+"fixed"+String(e)+"x"+String(i);return{signed:t,width:e,decimals:i,name:n}}function y(s,t){let e="";s<u&&(e="-",s*=A);let i=s.toString();if(t===0)return e+i;for(;i.length<=t;)i=m+i;const n=i.length-t;for(i=i.substring(0,n)+"."+i.substring(n);i[0]==="0"&&i[1]!==".";)i=i.substring(1);for(;i[i.length-1]==="0"&&i[i.length-2]!==".";)i=i.substring(0,i.length-1);return e+i}class h{format;#e;#t;#i;_value;constructor(t,e,i){B(t,c,"FixedNumber"),this.#t=e,this.#e=i;const n=y(e,i.decimals);x(this,{format:i.name,_value:n}),this.#i=f(i.decimals)}get signed(){return this.#e.signed}get width(){return this.#e.width}get decimals(){return this.#e.decimals}get value(){return this.#t}#s(t){d(this.format===t.format,"incompatible format; use fixedNumber.toFormat","other",t)}#n(t,e){return t=v(t,this.#e,e),new h(c,t,this.#e)}#r(t,e){return this.#s(t),this.#n(this.#t+t.#t,e)}addUnsafe(t){return this.#r(t)}add(t){return this.#r(t,"add")}#o(t,e){return this.#s(t),this.#n(this.#t-t.#t,e)}subUnsafe(t){return this.#o(t)}sub(t){return this.#o(t,"sub")}#l(t,e){return this.#s(t),this.#n(this.#t*t.#t/this.#i,e)}mulUnsafe(t){return this.#l(t)}mul(t){return this.#l(t,"mul")}mulSignal(t){this.#s(t);const e=this.#t*t.#t;return a(e%this.#i===u,"precision lost during signalling mul","NUMERIC_FAULT",{operation:"mulSignal",fault:"underflow",value:this}),this.#n(e/this.#i,"mulSignal")}#u(t,e){return a(t.#t!==u,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),this.#s(t),this.#n(this.#t*this.#i/t.#t,e)}divUnsafe(t){return this.#u(t)}div(t){return this.#u(t,"div")}divSignal(t){a(t.#t!==u,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),this.#s(t);const e=this.#t*this.#i;return a(e%t.#t===u,"precision lost during signalling div","NUMERIC_FAULT",{operation:"divSignal",fault:"underflow",value:this}),this.#n(e/t.#t,"divSignal")}cmp(t){let e=this.value,i=t.value;const n=this.decimals-t.decimals;return n>0?i*=f(n):n<0&&(e*=f(-n)),e<i?-1:e>i?1:0}eq(t){return this.cmp(t)===0}lt(t){return this.cmp(t)<0}lte(t){return this.cmp(t)<=0}gt(t){return this.cmp(t)>0}gte(t){return this.cmp(t)>=0}floor(){let t=this.#t;return this.#t<u&&(t-=this.#i-g),t=this.#t/this.#i*this.#i,this.#n(t,"floor")}ceiling(){let t=this.#t;return this.#t>u&&(t+=this.#i-g),t=this.#t/this.#i*this.#i,this.#n(t,"ceiling")}round(t){if(t==null&&(t=0),t>=this.decimals)return this;const e=this.decimals-t,i=E*f(e-1);let n=this.value+i;const r=f(e);return n=n/r*r,v(n,this.#e,"round"),new h(c,n,this.#e)}isZero(){return this.#t===u}isNegative(){return this.#t<u}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return h.fromString(this.toString(),t)}static fromValue(t,e,i){const n=e==null?0:I(e),r=p(i);let o=N(t,"value");const l=n-r.decimals;if(l>0){const w=f(l);a(o%w===u,"value loses precision for format","NUMERIC_FAULT",{operation:"fromValue",fault:"underflow",value:t}),o/=w}else l<0&&(o*=f(-l));return v(o,r,"fromValue"),new h(c,o,r)}static fromString(t,e){const i=t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);d(i&&i[2].length+i[3].length>0,"invalid FixedNumber string value","value",t);const n=p(e);let r=i[2]||"0",o=i[3]||"";for(;o.length<n.decimals;)o+=m;a(o.substring(n.decimals).match(/^0*$/),"too many decimals for format","NUMERIC_FAULT",{operation:"fromString",fault:"underflow",value:t}),o=o.substring(0,n.decimals);const l=BigInt(i[1]+r+o);return v(l,n,"fromString"),new h(c,l,n)}static fromBytes(t,e){let i=F(T(t,"value"));const n=p(e);return n.signed&&(i=b(i,n.width)),v(i,n,"fromBytes"),new h(c,i,n)}}const C=["wei","kwei","mwei","gwei","szabo","finney","ether"];function L(s,t){let e=18;if(typeof t=="string"){const i=C.indexOf(t);d(i>=0,"invalid unit","unit",t),e=3*i}else t!=null&&(e=I(t,"unit"));return h.fromValue(s,e,{decimals:e,width:512}).toString()}function R(s){return L(s,18)}export{L as a,R as f};
